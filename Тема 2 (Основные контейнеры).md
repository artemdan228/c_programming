# Контейнер `std::vector`
Для создания вектора необходимо подключить библиотеку `<vector>`
```cpp
#include <iostream>  
#include <vector>  
int main() { 
	std::vector<int> data = {10, 20, 30}; 
	for (int elem : data) { 
		std::cout << elem << " "; 
	} 
	std::cout << "\n"; 
}
```
## Основные операции:
### 1. 
`operator[](size_t index)`— доступ к элементу по индексу без проверки границ
```cpp
std::vector<int> data = {1, 2, 3, 4, 5};
int a = data[0];  // начальный элемент вектора
int b = data[4];  // последний элемент вектора (в нём пять элементов)
data[2] = -3;  // меняем элемент 3 на -3
```
### 2. 
`at(size_t index)` — доступ к элементу по индексу с проверкой выхода за границы
```cpp
std::vector<int> data = {1, 2, 3, 4, 5};
std::cout << data[42] << "\n";  // неопределённое поведение: может произойти всё что угодно
std::cout << data.at(0) << "\n";  // напечатается 1
std::cout << data.at(42) << "\n";  // произойдёт исключение std::out_of_range — его можно будет перехватить и обработать
```
### 3. 
`push_back(const T& value)` — добавить элемент в конец контейнера  
`pop_back()` — удалить последний элемент контейнера  
`front()` — получить первый элемент  
`back()` — получить последний элемент  
`size()` — текущий размер контейнера  
`clear()` — очистить контейнер (не освобождает зарезервированную память)  
```cpp
#include <iostream>  
#include <vector>  
int main() { 
	std::vector<int> data = {10, 20, 30}; 
	vec.push_back(40); // Вектор станет {10, 20, 30, 40}
	vec.pop_back(); // Вектор станет {10, 20, 30}
}40}
	std::cout << vec.front(); // Вывод: 10
	std::cout << vec.back(); // Вывод: 30
	std::cout << vec.size(); // Вывод: 3
	vec.clear(); // Вектор станет пустым {}
```
### 4. 
`reserve(size_t n)` — зарезервировать память для хранения минимум `n` элементов  
`resize(size_t n, const T& value = T())` — изменить размер и заполнить новые элементы значением `value`  
`capacity()` — текущая емкость контейнера (размер зарезервированной памяти)  
`insert(iterator pos, const T& value)` — вставить элемент по позиции  
`erase(iterator pos)` — удалить элемент по позиции  
`emplace_back(Args&&... args)` — создать и добавить элемент в конец (без копирования)  
`swap(std::vector& other)` — обменять содержимое двух векторов  
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3};

    // Добавление элементов
    vec.push_back(4); 
    vec.emplace_back(5);

    // Доступ к элементам
    std::cout << "First: " << vec.front() << ", Last: " << vec.back() << std::endl;
    // Ожидаемый вывод: First: 1, Last: 5

    // Изменение размера и резервирование памяти
    vec.resize(7, 42);
    vec.reserve(10);
    std::cout << "Size: " << vec.size() << ", Capacity: " << vec.capacity() << std::endl;
    // Ожидаемый вывод: Size: 7, Capacity: 10

    // Вставка и удаление
    vec.insert(vec.begin() + 1, 99);
    vec.erase(vec.begin() + 3);
    std::cout << "After insert/erase: ";
    for (int val : vec) std::cout << val << " ";
    std::cout << std::endl;
    // Ожидаемый вывод: After insert/erase: 1 99 2 42 42 42 

    // Очистка и проверка
    vec.clear();
    std::cout << "Is empty: " << (vec.empty() ? "Yes" : "No") << std::endl;
    // Ожидаемый вывод: Is empty: Yes

    return 0;
}
```

## Сортировка векторов с библиотеки `<algorithm>` методом `std::sort()`
```cpp
#include <algorithm>
#include <vector>

int main() {
    std::vector<int> data = {3, 1, 4, 1, 5, 9, 2, 6};

    // Сортировка диапазона вектора от начала до конца и наоборот
    std::sort(data.begin(), data.end());
	// 1, 1, 2, 3, 4, 5, 6, 9
    
    std::sort(data.rbegin(), data.rend()); 
    // 9, 6, 5, 4, 3, 2, 1, 1
}
```


# Контейнер `std::string`
